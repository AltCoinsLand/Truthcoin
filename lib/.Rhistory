QueryMoveCost("Obama",1,.7)
QueryMoveCost("Obama",1,.90)
QueryMoveCost("Obama",1,.99)
QueryMoveCost("Hillary",1,.25)
QueryMoveCost("Hillary",1,.35)
QueryMoveCost("Hillary",1,.45)
QueryMoveCost("Hillary",1,.90)
QueryMoveCost("Hillary",1,.99)
Buy <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(is.character(MarginalShares)) return(MarginalShares)
#Reduce Funds, add Shares
if(Users[[uID]]$Cash<Cost) return("Insufficient Funds")
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost
OldShares <- Users[[uID]][[ID]][State] ; if(is.null(OldShares)) OldShares <- 0
Users[[uID]][[ID]]$State <<- OldShares + MarginalShares
#Credit Funds, add Shares
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
}
Sell <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
#Reduce shares, add Funds
if(Users[[uID]][[ID]][State]<MarginalShares) return("Insufficient Shares")
Users[[uID]][[ID]][State] <<- Users[[uID]][[ID]][State] - MarginalShares
Users[[uID]]$Cash <<-  Users[[uID]]$Cash + Cost
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance - Cost #!
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] - MarginalShares
}
Users
Buy("Alice","Obama",1,.6)
ShowPrices("Obama")
Users
Buy("Alice","Obama",1,.7)
#
# Buy("Alice","Hillary",2,.35)
# ShowPrices("Hillary")
# Buy("Bob","Hillary",3,.60)
# ShowPrices("Hillary")
#
# Users$Alice
# Users$Bob
#Trading Protocol and Market Maker
#MarketPlace
Markets <- vector("list",length=0)
Users <- vector("list",length=0)
Users$Alice$Cash <- 10
Users$Bob$Cash <- 50
Users$Charlie$Cash <- 78
#New Contract
CreateMarket <- function(ID=1,Nstates=2,B=1) {
Markets[[ID]] <<- list(
"Shares"=rep(0,length=Nstates),
"Balance"=B*log(Nstates),
"B"=B,
"State"=0)
}
Markets
CreateMarket("Obama",2,B=1)
CreateMarket("Hillary",4,B=3.5)
Markets
Markets$Obama$Price
ShowPrices <- function(ID) {
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
return(S/sum(S))
}
ShowPrices("Obama")
ShowPrices("Hillary")
QueryMove <- function(ID,State,P) {
#How many shares would I need to buy to move the probability to X
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
Sstar <- Markets[[ID]]$B* ( log(P/(1-P)) + log(sum(S[-State])) )
Marginal <- Sstar -Markets[[ID]]$Shares[State]
return(Marginal)
}
QueryMove("Obama",1,.6)
QueryMove("Obama",2,.4)
QueryMove("Hillary",3,.35)
QueryCost <- function(ID,State,S) {
#Original Case
S0 <- Markets[[ID]]$Shares
B <- Markets[[ID]]$B
LMSR <- B*log(sum(exp(S0/B)))
#Proposed Adjustment
S1 <- S0
S1[State] <- S1[State] + S
LMSR2 <- B*log(sum(exp(S1/B)))
return( LMSR2-LMSR )
}
QueryCost("Obama",2,1)
QueryCost("Hillary",1,1)
QueryMoveCost <- function(ID,State,P) {
NewS <- QueryMove(ID,State,P)
if(NewS<0) return("Price already exceeds target. Sell shares or buy MuEx.")
return( QueryCost(ID,State, NewS ) )
}
QueryMoveCost("Obama",1,.5)
QueryMoveCost("Obama",1,.6)
QueryMoveCost("Obama",1,.7)
QueryMoveCost("Obama",1,.90)
QueryMoveCost("Obama",1,.99)
QueryMoveCost("Hillary",1,.25)
QueryMoveCost("Hillary",1,.35)
QueryMoveCost("Hillary",1,.45)
QueryMoveCost("Hillary",1,.90)
QueryMoveCost("Hillary",1,.99)
Buy <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(is.character(MarginalShares)) return(MarginalShares)
#Reduce Funds, add Shares
if(Users[[uID]]$Cash<Cost) return("Insufficient Funds")
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost
OldShares <- Users[[uID]][[ID]][[State]] ; if(is.null(OldShares)) OldShares <- 0
Users[[uID]][[ID]][[State]] <<- OldShares + MarginalShares
#Credit Funds, add Shares
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
}
Sell <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
#Reduce shares, add Funds
if(Users[[uID]][[ID]][State]<MarginalShares) return("Insufficient Shares")
Users[[uID]][[ID]][State] <<- Users[[uID]][[ID]][State] - MarginalShares
Users[[uID]]$Cash <<-  Users[[uID]]$Cash + Cost
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance - Cost #!
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] - MarginalShares
}
Users
Buy("Alice","Obama",1,.6)
ShowPrices("Obama")
Users
Buy("Alice","Obama",1,.7)
#
# Buy("Alice","Hillary",2,.35)
# ShowPrices("Hillary")
# Buy("Bob","Hillary",3,.60)
# ShowPrices("Hillary")
#
# Users$Alice
# Users$Bob
#Trading Protocol and Market Maker
#MarketPlace
Markets <- vector("list",length=0)
Users <- vector("list",length=0)
Users$Alice$Cash <- 10
Users$Bob$Cash <- 50
Users$Charlie$Cash <- 78
#New Contract
CreateMarket <- function(ID=1,Nstates=2,B=1) {
Markets[[ID]] <<- list(
"Shares"=rep(0,length=Nstates),
"Balance"=B*log(Nstates),
"B"=B,
"State"=0)
}
Markets
CreateMarket("Obama",2,B=1)
CreateMarket("Hillary",4,B=3.5)
Markets
Markets$Obama$Price
ShowPrices <- function(ID) {
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
return(S/sum(S))
}
ShowPrices("Obama")
ShowPrices("Hillary")
QueryMove <- function(ID,State,P) {
#How many shares would I need to buy to move the probability to X
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
Sstar <- Markets[[ID]]$B* ( log(P/(1-P)) + log(sum(S[-State])) )
Marginal <- Sstar -Markets[[ID]]$Shares[State]
return(Marginal)
}
QueryMove("Obama",1,.6)
QueryMove("Obama",2,.4)
QueryMove("Hillary",3,.35)
QueryCost <- function(ID,State,S) {
#Original Case
S0 <- Markets[[ID]]$Shares
B <- Markets[[ID]]$B
LMSR <- B*log(sum(exp(S0/B)))
#Proposed Adjustment
S1 <- S0
S1[State] <- S1[State] + S
LMSR2 <- B*log(sum(exp(S1/B)))
return( LMSR2-LMSR )
}
QueryCost("Obama",2,1)
QueryCost("Hillary",1,1)
QueryMoveCost <- function(ID,State,P) {
NewS <- QueryMove(ID,State,P)
if(NewS<0) return("Price already exceeds target. Sell shares or buy MuEx.")
return( QueryCost(ID,State, NewS ) )
}
QueryMoveCost("Obama",1,.5)
QueryMoveCost("Obama",1,.6)
QueryMoveCost("Obama",1,.7)
QueryMoveCost("Obama",1,.90)
QueryMoveCost("Obama",1,.99)
QueryMoveCost("Hillary",1,.25)
QueryMoveCost("Hillary",1,.35)
QueryMoveCost("Hillary",1,.45)
QueryMoveCost("Hillary",1,.90)
QueryMoveCost("Hillary",1,.99)
Buy <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(is.character(MarginalShares)) return(MarginalShares)
#Reduce Funds, add Shares
if(Users[[uID]]$Cash<Cost) return("Insufficient Funds")
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost
OldShares <- Users[[uID]][[ID]][[State]] ; if(is.null(OldShares)) OldShares <- 0
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares + MarginalShares
#Credit Funds, add Shares
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
}
Sell <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
#Reduce shares, add Funds
if(Users[[uID]][[ID]][State]<MarginalShares) return("Insufficient Shares")
Users[[uID]][[ID]][State] <<- Users[[uID]][[ID]][State] - MarginalShares
Users[[uID]]$Cash <<-  Users[[uID]]$Cash + Cost
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance - Cost #!
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] - MarginalShares
}
Users
Buy("Alice","Obama",1,.6)
ShowPrices("Obama")
Users
Buy("Alice","Obama",1,.7)
#
# Buy("Alice","Hillary",2,.35)
# ShowPrices("Hillary")
# Buy("Bob","Hillary",3,.60)
# ShowPrices("Hillary")
#
# Users$Alice
# Users$Bob
#Trading Protocol and Market Maker
#MarketPlace
Markets <- vector("list",length=0)
Users <- vector("list",length=0)
Users$Alice$Cash <- 10
Users$Bob$Cash <- 50
Users$Charlie$Cash <- 78
#New Contract
CreateMarket <- function(ID=1,Nstates=2,B=1) {
Markets[[ID]] <<- list(
"Shares"=rep(0,length=Nstates),
"Balance"=B*log(Nstates),
"B"=B,
"State"=0)
}
Markets
CreateMarket("Obama",2,B=1)
CreateMarket("Hillary",4,B=3.5)
Markets
Markets$Obama$Price
ShowPrices <- function(ID) {
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
return(S/sum(S))
}
ShowPrices("Obama")
ShowPrices("Hillary")
QueryMove <- function(ID,State,P) {
#How many shares would I need to buy to move the probability to X
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
Sstar <- Markets[[ID]]$B* ( log(P/(1-P)) + log(sum(S[-State])) )
Marginal <- Sstar -Markets[[ID]]$Shares[State]
return(Marginal)
}
QueryMove("Obama",1,.6)
QueryMove("Obama",2,.4)
QueryMove("Hillary",3,.35)
QueryCost <- function(ID,State,S) {
#Original Case
S0 <- Markets[[ID]]$Shares
B <- Markets[[ID]]$B
LMSR <- B*log(sum(exp(S0/B)))
#Proposed Adjustment
S1 <- S0
S1[State] <- S1[State] + S
LMSR2 <- B*log(sum(exp(S1/B)))
return( LMSR2-LMSR )
}
QueryCost("Obama",2,1)
QueryCost("Hillary",1,1)
QueryMoveCost <- function(ID,State,P) {
NewS <- QueryMove(ID,State,P)
if(NewS<0) return("Price already exceeds target. Sell shares or buy MuEx.")
return( QueryCost(ID,State, NewS ) )
}
QueryMoveCost("Obama",1,.5)
QueryMoveCost("Obama",1,.6)
QueryMoveCost("Obama",1,.7)
QueryMoveCost("Obama",1,.90)
QueryMoveCost("Obama",1,.99)
QueryMoveCost("Hillary",1,.25)
QueryMoveCost("Hillary",1,.35)
QueryMoveCost("Hillary",1,.45)
QueryMoveCost("Hillary",1,.90)
QueryMoveCost("Hillary",1,.99)
Buy <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(is.character(MarginalShares)) return(MarginalShares)
#Reduce Funds, add Shares
if(Users[[uID]]$Cash<Cost) return("Insufficient Funds")
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost
OldShares <- Users[[uID]][[ID]][[State]] ; if(is.null(OldShares)) OldShares <- 0
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares + MarginalShares
#Credit Funds, add Shares
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
}
Sell <- function(uID,ID,State,P) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(is.character(MarginalShares)) return(MarginalShares)
#Reduce shares, add Funds
OldShares <- Users[[uID]][[ID]][[paste("State",State,sep="")]]
if(OldShares<MarginalShares) return("Insufficient Shares")
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares - MarginalShares
Users[[uID]]$Cash <<-  Users[[uID]]$Cash + Cost
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance - Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] - MarginalShares
}
Users
Buy("Alice","Obama",1,.6)
ShowPrices("Obama")
Users
Buy("Alice","Obama",1,.7)
#
# Buy("Alice","Hillary",2,.35)
# ShowPrices("Hillary")
# Buy("Bob","Hillary",3,.60)
# ShowPrices("Hillary")
#
# Users$Alice
# Users$Bob
Buy("Bob","Obama",1,.7)
Users
Sell("Alice","Obama",1,.55)
GetWeight <- function(vec,AddMean=FALSE) {
#Takes a vector, absolute value, then proportional linear deviance from 0.
new <- abs(vec)
if(AddMean==1) new  <- new + mean(new)
if(sum(new)==0) new <- new + 1
new <- new/sum(new)
return(new)
}
GetWeights(c(3,4,5,6))
GetWeights(c(3,4,5,6))
GetWeight(c(3,4,5,6))
### Trading Protocol and Market Maker ###
# try(setwd("~/GitHub/Truthcoin/lib"))
source(file="market/Markets.r")
#Global Parameter
FeeRate <<- .01
## Simple Market Info ##
ShowPrices <- function(ID) {
#Takes a Market and ID and returns the current market price.
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
return(S/sum(S))
}
QueryMove <- function(ID,State,P) {
#How many shares would I need to buy of'ID'-'State' to move the probability to 'P'?
S <- exp(Markets[[ID]]$Shares/Markets[[ID]]$B)
Sstar <- Markets[[ID]]$B* ( log(P/(1-P)) + log(sum(S[-State])) )
Marginal <- Sstar -Markets[[ID]]$Shares[State]
return(Marginal)
}
QueryCost <- function(ID,State,S) {
#What price will the market-maker demand for a purchase of S shares?
B <- Markets[[ID]]$B
#Original Case
S0 <- Markets[[ID]]$Shares
LMSR <- B*log(sum(exp(S0/B)))
#Proposed Adjustment
S1 <- S0;  S1[State] <- S1[State] + S
LMSR2 <- B*log(sum(exp(S1/B)))
return( LMSR2-LMSR )
}
QueryMoveCost <- function(ID,State,P) {
#How much would it cost to set the probability to P?
NewS <- QueryMove(ID,State,P)
return( QueryCost(ID,State, NewS ) )
}
## User Accounts ##
Users <- vector("list",length=0) #Critical Step...creates (blank) marketplace. Would erase the existing marketplace if called twice.
CreateAccount <- function(Name,Qfunds) {
#Creates an account filled with money.
#Obviously, this is a crucial step which will require (!) verification of Bitcoin payments, an X-confirmation delay, etc. For testing we allow unconstrained (free/infinite) cash.
#These accounts have simple toy names, actual accounts will probably be the bitcoin addresses themselves.
Users[[Name]]$Cash <<- Qfunds
}
## Buying and Selling Shares ##
Buy <- function(uID,ID,State,P,Verbose=TRUE) {
#Calculate Required Cost
BaseCost <- QueryMoveCost(ID,State,P) #trade cost assuming no fees
Fee <- BaseCost*FeeRate               #fees for buying only (global parameter set at top)
TotalCost <- BaseCost + Fee           #Total cost including Fee
MarginalShares <- QueryMove(ID,State,P)
if(MarginalShares<0) return("Price already exceeds target. Sell shares or buy a Mutually Exclusive State (MES).")
if(Verbose) { print(paste("Calulating Required Shares...",MarginalShares)); print(paste("Determining Cost of Trade...",BaseCost)); print(paste("Fee:",Fee)) }
#Reduce Funds, add Shares
if( Users[[uID]]$Cash < TotalCost) return("Insufficient Funds")
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - TotalCost
OldShares <- Users[[uID]][[ID]][[paste("State",State,sep="")]] ; if(is.null(OldShares)) OldShares <- 0
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares + MarginalShares
#Credit Funds, add Shares
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + BaseCost
Markets[[ID]]$FeeBalance <<-  Markets[[ID]]$FeeBalance + Fee
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
if(Verbose) print(paste("Bought",MarginalShares,"for",TotalCost,"."))
return(c(MarginalShares,TotalCost))
}
Sell <- function(uID,ID,State,P,Verbose=TRUE) {
#Calculate Required Cost
Cost <- QueryMoveCost(ID,State,P)
MarginalShares <- QueryMove(ID,State,P)
if(MarginalShares>0) return("Price already below target. Buy shares or sell a Mutually Exclusive State (MES).")
if(Verbose) { print("Calulating Required Shares..."); print(MarginalShares); print("Determining Cost of Trade..."); print(Cost) }
#Reduce shares, add Funds
OldShares <- Users[[uID]][[ID]][[paste("State",State,sep="")]]
if(OldShares<(-1*MarginalShares)) return("Insufficient Shares") #Remember, shares are negative.
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares + MarginalShares
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost #Cost is also negative
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
if(Verbose) print(paste("Sold",-1*MarginalShares,"for",-1*Cost,"."))
return(c(MarginalShares,Cost))
}
## NOT DONE !!!
FinalSell <- function(uID,ID,State,S,Verbose=TRUE) {
#This function takes over after the event's state has been determined, and all shares are either worth zero or the unit price.
Judged <- BlockChain[[length(BlockChain)]]$Jmatrix
ContractState <- -2
ContractState <- try(Judged[Judged$Contract==ID,2])
if(Verbose) print(paste("Determined State of this Market:", ContractState))
#Which shares are valuable?
if(ContractState<0) return("You cannot sell using this function until there is a consensus about the outcome.")
if(State!=ContractState) return("Shares of this state have value 0.")
OldShares <- Users[[uID]][[ID]][[paste("State",State,sep="")]]
MarginalShares <- S*-1 #Users are expected to enter +3 if they wish to sell 3 shares, ie marginally change shares by -3.
Cost <- MarginalShares # All shares have value 1, so this identiy holds.
#Reduce shares, add Funds
Users[[uID]][[ID]][[paste("State",State,sep="")]] <<- OldShares + MarginalShares #MarginalShares are negative
Users[[uID]]$Cash <<-  Users[[uID]]$Cash - Cost #Cost is negative
#Remove Funds and Shares from Market
Markets[[ID]]$Balance <<-  Markets[[ID]]$Balance + Cost
Markets[[ID]]$Shares[State] <<- Markets[[ID]]$Shares[State] + MarginalShares
if(Verbose) print(paste("FinalSold",-1*MarginalShares,"for",-1*Cost,"."))
return(c(MarginalShares,Cost))
}
QueryCost('Obama2012',1,2)
CreateAccount("Alice",10)
CreateAccount("Bob",50)
Users
Markets
CreateMarket(Title="Obama",
B=1,
D.State=list(
c("Did Barack H Obama win the United States 2012 presidential election?")
),
Description="Barack Obama to win United States President in 2012\nThis contract will expire in state 1 if the statement is true and 0 otherwise.",
Tags=c("Politics, UnitedStates, President, Winner"),
MatureTime=5,
OwnerAd="1Loxo4RsiokFYXgpjc4CezGAmYnDwaydWh")
#Source
rm(list=ls())
tryCatch(expr=setwd("~/GitHub/Truthcoin/lib"), error=function(e) setwd(choose.dir(caption="Failed to set working directory automatically. Choose 'lib' folder:")) )
source("market/Trading.R")
CreateAccount("Alice",10)
CreateAccount("Bob",50)
Users
Markets
CreateMarket(Title="Obama",
B=1,
D.State=list(
c("Did Barack H Obama win the United States 2012 presidential election?")
),
Description="Barack Obama to win United States President in 2012\nThis contract will expire in state 1 if the statement is true and 0 otherwise.",
Tags=c("Politics, UnitedStates, President, Winner"),
MatureTime=5,
OwnerAd="1Loxo4RsiokFYXgpjc4CezGAmYnDwaydWh")
QueryCost('Obama',1,2)
QueryMoveCost('Obama',1,.7)
Markets
QueryMoveCost('Obama',1,.7)
QueryMoveCost('Obama',1,.7)
QueryMoveCost('Obama',1,.7)
Buy(uID="Bob","Obama",1,.7,Verbose=TRUE)
